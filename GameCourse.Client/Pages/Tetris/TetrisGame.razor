@page "/games/tetris"
@using System.Collections.Concurrent
@rendermode InteractiveWebAssembly

<PageTitle>TetrisGame</PageTitle>

<div @ref="gameUIElement" tabindex="0" id="gameContainer" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp">
    <CascadingValue Value="Options">
        @if (!@isLoaded)
        {
            <p>Loading</p>
        }
        else
        {
            <button @onclick="StartButtonClicked">@GetButtonText()</button>
            <div id="canvas" style="@canvasStyle">
                <!-- Active Block -->
                <TetrisBlock BlockObject="@(GameCanvas.ActiveBlock)"></TetrisBlock>
                <!-- End of Active Block -->
                <!-- Canvas cells -->
                @for (int row = 0; row < GameCanvas.Rows; row++)
                {
                    for (int column = 0; column < GameCanvas.Columns; column++)
                    {
                        <div id="CanvasCell_@(row)_@(column)" class="@(GameCanvas.Points[row,column].IsOccupied ? "CanvasCell" : "EmptyCanvasCell")" style="background-color: @(GameCanvas.Points[row,column].Color)"></div>
                    }
                }
                <!-- End of Canvas cells -->
            </div>
        }
    </CascadingValue>
</div>

@code {
    enum Keys
    {
        Up,
        Right,
        Down,
        Left
    }

    enum GameStatus
    {
        Stopped,
        Running,
        Loose
    }

    bool isLoaded = false;
    ElementReference gameUIElement;

    GameOptions Options = new GameOptions()
        {
            CanvasRowsCount = 18,
            CanvasColumnsCount = 12,
            CellSize = 40
        };

    Canvas GameCanvas;
    GameStatus TetrisGameStatus = GameStatus.Stopped;

    ConcurrentDictionary<Keys, Object> PressedKeys = new ConcurrentDictionary<Keys, Object>();
    ConcurrentDictionary<Keys, Object> KeysWaitingForProcess = new ConcurrentDictionary<Keys, Object>();


    string canvasStyle = "";

    System.Timers.Timer loopTimer = new System.Timers.Timer(2000);
    private object timerLock = new object();

    private string GetButtonText()
    {
        return TetrisGameStatus switch
        {
            GameStatus.Stopped => "Start",
            GameStatus.Running => "Stop",
            GameStatus.Loose => "Loose",
            _ => "Error"
        };
    }

    bool processedKeyTap = false;
    bool isLongPressing = false;

    private void GameLoop(object? source, System.Timers.ElapsedEventArgs? args)
    {
        Monitor.Enter(timerLock);

        loopTimer.Interval = 1000;
        Console.WriteLine("Set interval: 1000");
        if (PressedKeys.Count == 0)// || processedKeyTap)
        {
            if (source == loopTimer)
            {
                GameCanvas.MoveActiveBlockTo(Direction.Down);
            }

            processedKeyTap = KeysWaitingForProcess.Count > 0;

            if (KeysWaitingForProcess.ContainsKey(Keys.Up))
            {
                GameCanvas.TurnActiveBlock();
                KeysWaitingForProcess.TryRemove(Keys.Up, out _);
            }
            if (KeysWaitingForProcess.ContainsKey(Keys.Left))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Left);
                KeysWaitingForProcess.TryRemove(Keys.Left, out _);
            }
            if (KeysWaitingForProcess.ContainsKey(Keys.Right))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Right);
                KeysWaitingForProcess.TryRemove(Keys.Right, out _);
            }
            if (KeysWaitingForProcess.ContainsKey(Keys.Down))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Down);
                KeysWaitingForProcess.TryRemove(Keys.Down, out _);
            }

            loopTimer.Interval = processedKeyTap ? 300 : 1000;
        }
        else
        {
            if (!isLongPressing)
            {
                loopTimer.Interval = 1000;
                isLongPressing = true;
            }
            else
            {
                loopTimer.Interval = 50;
            }
            if (PressedKeys.ContainsKey(Keys.Up))
            {
                GameCanvas.TurnActiveBlock();
            }
            if (PressedKeys.ContainsKey(Keys.Left))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Left);
            }
            if (PressedKeys.ContainsKey(Keys.Right))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Right);
            }
            if (PressedKeys.ContainsKey(Keys.Down))
            {
                GameCanvas.MoveActiveBlockTo(Direction.Down);
            }
        }


        if (GameCanvas.IsCanvasFull)
        {
            TetrisGameStatus = GameStatus.Loose;
            // loopTimer.Stop();
        }

        StateHasChanged();

        if (!GameCanvas.IsCanvasFull)
        {
            loopTimer.Start();
        }

        Monitor.Exit(timerLock);
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        Console.WriteLine($"KeyDown: {e.Key}");
        switch (e.Key)
        {
            case "ArrowUp":
                PressedKeys.TryAdd(Keys.Up, null);
                KeysWaitingForProcess.TryAdd(Keys.Up, null);
                break;
            case "ArrowLeft":
                PressedKeys.TryAdd(Keys.Left, null);
                KeysWaitingForProcess.TryAdd(Keys.Left, null);
                break;
            case "ArrowDown":
                PressedKeys.TryAdd(Keys.Down, null);
                KeysWaitingForProcess.TryAdd(Keys.Down, null);
                break;
            case "ArrowRight":
                PressedKeys.TryAdd(Keys.Right, null);
                KeysWaitingForProcess.TryAdd(Keys.Right, null);
                break;
            default:
                break;
        }
        GameLoop(null, null);
    }

    private void OnKeyUp(KeyboardEventArgs e)
    {
        Console.WriteLine($"KeyUp: {e.Key}");
        switch (e.Key)
        {
            case "ArrowUp":
                PressedKeys.TryRemove(Keys.Up, out _);
                break;
            case "ArrowLeft":
                PressedKeys.TryRemove(Keys.Left, out _);
                break;
            case "ArrowDown":
                PressedKeys.TryRemove(Keys.Down, out _);
                break;
            case "ArrowRight":
                PressedKeys.TryRemove(Keys.Right, out _);
                break;
            default:
                break;
        }
        isLongPressing = false;
    }

    private void StartNewCanvas()
    {
        canvasStyle = $"width: {Options.CanvasColumnsCount * Options.CellSize + 8}px; height: {Options.CanvasRowsCount * Options.CellSize + 8}px; grid-template-columns: repeat({Options.CanvasColumnsCount}, {Options.CellSize}px); grid-template-rows: repeat({Options.CanvasRowsCount}, {Options.CellSize}px);";
        GameCanvas = new Canvas(Options);
    }

    protected override async Task OnParametersSetAsync()
    {
        StartNewCanvas();
        loopTimer.AutoReset = false;
        loopTimer.Elapsed += GameLoop;
        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isLoaded = true;
            StateHasChanged();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task StartButtonClicked(MouseEventArgs e)
    {
        switch (TetrisGameStatus)
        {
            case GameStatus.Stopped:
            case GameStatus.Loose:
                StartNewCanvas();
                TetrisGameStatus = GameStatus.Running;
                await gameUIElement.FocusAsync();
                loopTimer.Start();
                break;
            case GameStatus.Running:
                TetrisGameStatus = GameStatus.Stopped;
                loopTimer.Stop();
                break;
            default:
                break;
        }
    }
}